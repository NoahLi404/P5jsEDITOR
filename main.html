<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>p5.js Visual Editor - Smooth Select & Rotate</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<style>
  body {
    margin: 0;
    display: flex;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #1e1e2f;
    color: #ddd;
  }
  canvas {
    border: 1px solid #333;
    cursor: crosshair;
    background: #222233;
    box-shadow: 0 0 15px #00ffff88;
    transition: box-shadow 0.3s ease;
  }
  #tools {
    width: 320px;
    background: #2a2a42;
    padding: 15px 20px;
    box-shadow: inset 0 0 20px #00ffff44;
  }
  select, input[type=color], input[type=number], button {
    width: 100%;
    margin: 12px 0;
    padding: 10px;
    border-radius: 7px;
    border: none;
    font-size: 16px;
    outline: none;
    background: #444466;
    color: #0ff;
    box-shadow: 0 0 8px #00ffff77;
    transition: background-color 0.25s ease, box-shadow 0.25s ease;
  }
  select:hover, input[type=color]:hover, input[type=number]:hover, button:hover {
    background: #55ffffaa;
    box-shadow: 0 0 20px #00ffffcc;
    color: #111;
    cursor: pointer;
  }
  button:active {
    box-shadow: 0 0 25px #00ffffee inset;
  }
  .control-group {
    margin: 18px 0;
    padding: 12px 15px;
    border: 1px solid #00ffff88;
    border-radius: 12px;
    background: #222238dd;
    box-shadow: 0 0 15px #00ffff44 inset;
    transition: background-color 0.3s ease;
  }
  .control-group label {
    margin-bottom: 8px;
    display: block;
    font-weight: 600;
    color: #00ffffcc;
  }
  pre {
    background: #000011;
    color: #00ff99;
    padding: 15px;
    overflow: auto;
    height: 320px;
    border-radius: 12px;
    font-size: 14px;
    user-select: all;
    box-shadow: 0 0 20px #00ffccbb inset;
  }
  #transformControls {
    display: none;
  }

  /* Selection bounding box with glowing effect */
  .selection-box {
    position: absolute;
    border: 2.5px solid #00ffffcc;
    box-shadow: 0 0 20px #00ffffcc, 0 0 40px #00ffff99 inset;
    pointer-events: none;
    border-radius: 8px;
    transition: transform 0.15s ease;
  }

  /* Resize handles */
  .resize-handle {
    position: absolute;
    width: 14px;
    height: 14px;
    background: #00ffffcc;
    border-radius: 50%;
    box-shadow: 0 0 10px #00ffffcc;
    cursor: pointer;
    transition: background-color 0.25s ease, transform 0.25s ease;
  }
  .resize-handle:hover {
    background-color: #00ffffff;
    transform: scale(1.4);
  }

  /* Position handles */
  .handle-top-left { top: -10px; left: -10px; cursor: nwse-resize; }
  .handle-top-right { top: -10px; right: -10px; cursor: nesw-resize; }
  .handle-bottom-left { bottom: -10px; left: -10px; cursor: nesw-resize; }
  .handle-bottom-right { bottom: -10px; right: -10px; cursor: nwse-resize; }

</style>
</head>
<body>
  <div id="tools">
    <select id="tool">
      <option value="rect">Rectangle</option>
      <option value="ellipse">Ellipse</option>
      <option value="select">Select</option>
    </select>

    <div class="control-group">
      <label>Fill:</label>
      <input type="color" id="fillColor" value="#ff0000" />
    </div>

    <div class="control-group">
      <label>Stroke:</label>
      <input type="color" id="strokeColor" value="#000000" />
      <label>Stroke Weight:</label>
      <input type="number" id="strokeWeight" value="1" min="0" max="50" />
    </div>

    <div class="control-group" id="transformControls">
      <label>Rotate (drag selected shape horizontally to rotate)</label>
      <label>Resize by clicking handles or buttons below</label>
      <button id="increaseSizeBtn">+ Size</button>
      <button id="decreaseSizeBtn">- Size</button>
      <button id="flipHorizontalBtn">Flip Horizontal</button>
      <button id="flipVerticalBtn">Flip Vertical</button>
      <button id="deleteBtn" style="background:#ff0044; color:#fff;">Delete Selected</button>
    </div>

    <button onclick="clearCanvas()">Clear</button>
    <button onclick="copyCode()">Copy Code</button>
    <h3>Generated p5.js Code</h3>
    <pre id="codeBox"></pre>
  </div>

  <!-- Selection box + resize handles -->
  <div id="selectionBox" class="selection-box" style="display:none;">
    <div class="resize-handle handle-top-left"></div>
    <div class="resize-handle handle-top-right"></div>
    <div class="resize-handle handle-bottom-left"></div>
    <div class="resize-handle handle-bottom-right"></div>
  </div>

<script>
  let shapes = [];
  let currentTool = 'rect';
  let fillColor, strokeColor, strokeWeightVal;
  let startX, startY;
  let selectedShapeIndex = null;
  let draggingShape = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let rotating = false;
  let rotationStartX = 0;
  let rotationStartAngle = 0;

  const selectionBox = document.getElementById('selectionBox');
  const transformControls = document.getElementById('transformControls');
  const increaseSizeBtn = document.getElementById('increaseSizeBtn');
  const decreaseSizeBtn = document.getElementById('decreaseSizeBtn');
  const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
  const flipVerticalBtn = document.getElementById('flipVerticalBtn');
  const deleteBtn = document.getElementById('deleteBtn');

  function setup() {
    let canvas = createCanvas(window.innerWidth - 340, window.innerHeight);
    canvas.parent(document.body);

    fillColor = document.getElementById('fillColor');
    strokeColor = document.getElementById('strokeColor');
    strokeWeightVal = document.getElementById('strokeWeight');

    document.getElementById('tool').addEventListener('change', e => {
      currentTool = e.target.value;
      selectedShapeIndex = null;
      updateTransformUI();
      selectionBox.style.display = 'none';
      cursor(currentTool === 'select' ? 'default' : 'crosshair');
    });

    // Buttons
    increaseSizeBtn.onclick = () => { if(selectedShapeIndex !== null) changeSize(10); }
    decreaseSizeBtn.onclick = () => { if(selectedShapeIndex !== null) changeSize(-10); }
    flipHorizontalBtn.onclick = () => { if(selectedShapeIndex !== null) flipHorizontal(); }
    flipVerticalBtn.onclick = () => { if(selectedShapeIndex !== null) flipVertical(); }
    deleteBtn.onclick = () => { if(selectedShapeIndex !== null) deleteSelected(); }
  }

  function mousePressed() {
    if (mouseX < 0 || mouseY < 0 || mouseX > width || mouseY > height) return;

    if (currentTool === 'select') {
      if (selectedShapeIndex !== null) {
        // Check if clicked on resize handles (we'll check bounding box later)
        if (checkResizeHandleClicked(mouseX, mouseY)) {
          return;
        }
      }
      // Check if clicked inside any shape (top-down)
      selectedShapeIndex = null;
      for (let i = shapes.length - 1; i >= 0; i--) {
        if (isPointInShape(mouseX, mouseY, shapes[i])) {
          selectedShapeIndex = i;
          dragOffsetX = mouseX - shapes[i].x;
          dragOffsetY = mouseY - shapes[i].y;
          draggingShape = true;
          rotating = false;
          updateTransformUI();
          updateSelectionBox();
          return;
        }
      }
      // If clicked outside any shape, deselect
      selectedShapeIndex = null;
      draggingShape = false;
      updateTransformUI();
      selectionBox.style.display = 'none';
    } else {
      startX = mouseX;
      startY = mouseY;
      draggingShape = false;
    }
  }

  function mouseDragged() {
    if (rotating && selectedShapeIndex !== null) {
      // Calculate rotation based on horizontal mouse movement from start point
      let shape = shapes[selectedShapeIndex];
      let dx = mouseX - rotationStartX;
      let newRotation = rotationStartAngle + radians(dx);
      shape.rotation = newRotation;
      updateSelectionBox();
      updateCodeBox();
    } else if (draggingShape && selectedShapeIndex !== null && currentTool === 'select') {
      shapes[selectedShapeIndex].x = mouseX - dragOffsetX;
      shapes[selectedShapeIndex].y = mouseY - dragOffsetY;
      updateSelectionBox();
      updateCodeBox();
    }
  }

  function mouseReleased() {
    if (draggingShape) {
      draggingShape = false;
    }
    if (rotating) {
      rotating = false;
    }
    if (currentTool !== 'select') {
      if (mouseX > 0 && mouseY > 0) {
        let shape = {
          tool: currentTool,
          x: startX,
          y: startY,
          w: mouseX - startX,
          h: mouseY - startY,
          fill: fillColor.value,
          stroke: strokeColor.value,
          strokeWeight: parseInt(strokeWeightVal.value),
          rotation: 0,
          flipH: false,
          flipV: false
        };
        shapes.push(shape);
        updateCodeBox();
      }
    }
  }

  // Check if a point is inside shape (with rotation considered)
  function isPointInShape(px, py, shape) {
    // Translate point to shape coords and reverse rotate
    let cx = shape.x;
    let cy = shape.y;
    let angle = shape.rotation || 0;
    let cosA = cos(-angle);
    let sinA = sin(-angle);
    let dx = px - cx;
    let dy = py - cy;
    let xRot = dx * cosA - dy * sinA;
    let yRot = dx * sinA + dy * cosA;

    if (shape.tool === 'rect') {
      return xRot > 0 && xRot < shape.w && yRot > 0 && yRot < shape.h;
    } else if (shape.tool === 'ellipse') {
      let rx = abs(shape.w)/2;
      let ry = abs(shape.h)/2;
      return ((xRot - shape.w/2)**2)/(rx*rx) + ((yRot - shape.h/2)**2)/(ry*ry) <= 1;
    }
    return false;
  }

  // Update selection box UI around selected shape
  function updateSelectionBox() {
    if (selectedShapeIndex === null) {
      selectionBox.style.display = 'none';
      return;
    }
    const s = shapes[selectedShapeIndex];
    selectionBox.style.display = 'block';
    const canvasRect = document.querySelector('canvas').getBoundingClientRect();

    // Position and size selection box relative to canvas
    const left = canvasRect.left + s.x;
    const top = canvasRect.top + s.y;
    const w = abs(s.w);
    const h = abs(s.h);

    selectionBox.style.width = w + 'px';
    selectionBox.style.height = h + 'px';

    // Apply transform for rotation and flipping
    let transformStr = '';
    // Translate to center for rotation
    transformStr += `translate(${left + w/2}px, ${top + h/2}px) `;
    if (s.flipH) transformStr += 'scale(-1,1) ';
    if (s.flipV) transformStr += 'scale(1,-1) ';
    transformStr += `rotate(${degrees(s.rotation || 0)}deg) `;
    // Translate back top-left corner
    transformStr += `translate(${-w/2}px, ${-h/2}px)`;

    selectionBox.style.transform = transformStr;
    selectionBox.style.transformOrigin = 'center center';
  }

  // Resize handles interaction
  let currentHandle = null;
  let resizing = false;
  let resizeStartX = 0;
  let resizeStartY = 0;
  let resizeStartW = 0;
  let resizeStartH = 0;

  const handles = {
    'handle-top-left': [-1, -1],
    'handle-top-right': [1, -1],
    'handle-bottom-left': [-1, 1],
    'handle-bottom-right': [1, 1],
  };

  function checkResizeHandleClicked(px, py) {
    if (selectedShapeIndex === null) return false;
    const canvasRect = document.querySelector('canvas').getBoundingClientRect();
    const s = shapes[selectedShapeIndex];
    const left = canvasRect.left + s.x;
    const top = canvasRect.top + s.y;
    const w = abs(s.w);
    const h = abs(s.h);

    for (let handleClass in handles) {
      let handle = selectionBox.querySelector('.' + handleClass);
      let rect = handle.getBoundingClientRect();
      if (px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom) {
        currentHandle = handleClass;
        resizing = true;
        resizeStartX = px;
        resizeStartY = py;
        resizeStartW = w;
        resizeStartH = h;
        return true;
      }
    }
    return false;
  }

  window.addEventListener('mousemove', (e) => {
    if (resizing && selectedShapeIndex !== null) {
      let s = shapes[selectedShapeIndex];
      let dx = e.clientX - resizeStartX;
      let dy = e.clientY - resizeStartY;
      let [hx, hy] = handles[currentHandle];

      // Calculate new width and height
      let newW = resizeStartW + hx * dx;
      let newH = resizeStartH + hy * dy;

      if (newW < 10) newW = 10;
      if (newH < 10) newH = 10;

      s.w = s.w < 0 ? -newW : newW;
      s.h = s.h < 0 ? -newH : newH;

      updateSelectionBox();
      updateCodeBox();
    }
  });

  window.addEventListener('mouseup', (e) => {
    resizing = false;
    currentHandle = null;
  });

  // Rotate by dragging on shape: drag + hold 300ms then drag horizontally to rotate
  let rotateTimeout = null;
  let rotateStartMouseX = 0;

  selectionBox.addEventListener('mousedown', (e) => {
    if (currentTool !== 'select' || selectedShapeIndex === null) return;

    e.preventDefault();
    rotateTimeout = setTimeout(() => {
      rotating = true;
      rotationStartX = e.clientX;
      rotationStartAngle = shapes[selectedShapeIndex].rotation || 0;
    }, 300); // hold for 300ms to start rotate

    rotateStartMouseX = e.clientX;
  });

  selectionBox.addEventListener('mouseup', (e) => {
    clearTimeout(rotateTimeout);
    if (!rotating && selectedShapeIndex !== null) {
      // If released quickly (no rotate), treat as click to select - do nothing here, already selected
    }
    rotating = false;
  });

  // Increase/decrease size with buttons
  function changeSize(delta) {
    if (selectedShapeIndex === null) return;
    let s = shapes[selectedShapeIndex];
    let newW = abs(s.w) + delta;
    let newH = abs(s.h) + delta;
    if (newW < 10 || newH < 10) return;

    s.w = s.w < 0 ? -newW : newW;
    s.h = s.h < 0 ? -newH : newH;

    updateSelectionBox();
    updateCodeBox();
  }

  function flipHorizontal() {
    if (selectedShapeIndex === null) return;
    shapes[selectedShapeIndex].flipH = !shapes[selectedShapeIndex].flipH;
    updateSelectionBox();
    updateCodeBox();
  }

  function flipVertical() {
    if (selectedShapeIndex === null) return;
    shapes[selectedShapeIndex].flipV = !shapes[selectedShapeIndex].flipV;
    updateSelectionBox();
    updateCodeBox();
  }

  function deleteSelected() {
    if (selectedShapeIndex === null) return;
    shapes.splice(selectedShapeIndex, 1);
    selectedShapeIndex = null;
    selectionBox.style.display = 'none';
    updateTransformUI();
    updateCodeBox();
  }

  function updateTransformUI() {
    if (selectedShapeIndex === null) {
      transformControls.style.display = 'none';
    } else {
      transformControls.style.display = 'block';
      // Update fill/stroke colors and stroke weight UI to selected shape's values
      let s = shapes[selectedShapeIndex];
      fillColor.value = s.fill;
      strokeColor.value = s.stroke;
      strokeWeightVal.value = s.strokeWeight;
    }
  }

  function updateCodeBox() {
    let code = `function setup() {\n  createCanvas(${width}, ${height});\n}\n\nfunction draw() {\n  background(255);\n`;
    for (let s of shapes) {
      code += `  push();\n`;
      code += `  translate(${s.x + s.w/2}, ${s.y + s.h/2});\n`;
      if (s.flipH) code += `  scale(-1, 1);\n`;
      if (s.flipV) code += `  scale(1, -1);\n`;
      code += `  rotate(${s.rotation || 0});\n`;
      code += `  stroke("${s.stroke}");\n`;
      code += `  strokeWeight(${s.strokeWeight});\n`;
      code += `  fill("${s.fill}");\n`;
      if (s.tool === 'rect') {
        code += `  rectMode(CENTER);\n  rect(0, 0, ${s.w}, ${s.h});\n  rectMode(CORNER);\n`;
      } else if (s.tool === 'ellipse') {
        code += `  ellipse(0, 0, ${Math.abs(s.w)}, ${Math.abs(s.h)});\n`;
      }
      code += `  pop();\n`;
    }
    code += '}';
    document.getElementById('codeBox').textContent = code;
  }

  function clearCanvas() {
    shapes = [];
    selectedShapeIndex = null;
    selectionBox.style.display = 'none';
    updateTransformUI();
    updateCodeBox();
  }

  function copyCode() {
    const codeBox = document.getElementById('codeBox');
    navigator.clipboard.writeText(codeBox.textContent)
      .then(() => alert('Code copied to clipboard!'))
      .catch(() => alert('Failed to copy code.'));
  }

  function draw() {
    background(34, 34, 51);

    for (let i = 0; i < shapes.length; i++) {
      const s = shapes[i];
      push();
      translate(s.x + s.w / 2, s.y + s.h / 2);
      if (s.flipH) scale(-1, 1);
      if (s.flipV) scale(1, -1);
      rotate(s.rotation || 0);
      stroke(s.stroke);
      strokeWeight(s.strokeWeight);
      fill(s.fill);
      if (s.tool === 'rect') {
        rectMode(CENTER);
        rect(0, 0, s.w, s.h);
        rectMode(CORNER);
      } else if (s.tool === 'ellipse') {
        ellipse(0, 0, abs(s.w), abs(s.h));
      }
      pop();
    }
  }

  function windowResized() {
    resizeCanvas(window.innerWidth - 340, window.innerHeight);
    updateCodeBox();
    updateSelectionBox();
  }
</script>
</body>
</html>
